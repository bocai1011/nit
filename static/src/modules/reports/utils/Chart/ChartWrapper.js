/** @module reports/utils/Chart/ChartWrapper */

import React, { PropTypes } from 'react';
import {
    isFunction, isEmpty, pickBy, forEach, toPairs,
    unzip, zipObject, assign, mapValues, map,
} from 'lodash';
import util from 'common/utils/util';
import Chart from 'reports/utils/Chart/Chart';
import ChartItem from 'reports/utils/Chart/ChartItem';

/**
 * ChartWrapper is a React higher-order component (HOC). It accepts a
 * ReactClass as an argument (as well as some additional options) and returns a
 * new, augmented ReactClass. The purpose of the augmentation is to outfit the
 * wrapped component (in this case, a Report API Widget that displays some kind
 * of visualization) with the code that interfaces with the Report API.
 * The meat of the HOC lies in its two methods _update and _getData.
 */
export default function ChartWrapper(Widget, menuAdditions = {}) {

    return React.createClass({

        /**
         * A helper function that will execute all a Widget's Querys
         * and then update its state with the retrieved results.
         * To "execute a Query" in this sense means to generate its Promise
         * by calling `useData()` on it, and then waiting for the Promise to
         * either resolve or reject, at which point the Widget's state is set.
         *
         * For example, if the Widget has the following props:
         *
         * {
         *     title: 'Account vs. Broker',
         *     query: Query(...),
         *     group: Query(...),
         * }
         *
         * The Querys for `query` and `group` will be executed and
         * the Widget's state will be updated with an object called
         * `queryResults` that contains keys `query` and `group` with values
         * pointing to the data returned by the evaluated queries. If either of
         * those Querys fails in its execution and the Promise rejects, the
         * Widget's state will be updated with an `error` attribute pointing to
         * the error message generated by the rejected Promise.
         */
        _getData: function () {

            let
                queryKeys,
                dataPromises,

                // Extract all props from this Widget that are Querys.
                queries = pickBy(this.props, 'isQuery')
            ;

            // Convert the object of Querys into two lists:
            // the first contains the names (keys) for each Query;
            // the second (values) contains the Querys themselves.
            [ queryKeys, queries ] = unzip(toPairs(queries));

            // Execute all the Querys in parallel. If they all succeed,
            // add them to the Widget's state referenced by their original
            // names. If any of them failed, set the state to contain the error.
            dataPromises = Promise.all(queries.map(q => q.useData()));

            dataPromises = dataPromises.catch(error => {
                this.setState({
                    loading: false,
                    error
                });
            });

            dataPromises = dataPromises.then(data => {
                data = zipObject(queryKeys, data);
                this.setState({
                    loading: false,
                    queryResults: data,
                });
                return data;
            });

            return dataPromises;

        },

        /**
         * RAPI Methods
         * --------------------------------------------------------------------
         */

        /**
         * Retrieves new data for the Widget. It has a rudimentary locking
         * mechanism that will prevent this function from being called
         * unnecessarily many times. For example, if this Widget subscribes to
         * two Querys and they both issue it the same update instruction, it
         * will make two server requests for identical data. This prevents the
         * requests from happening more than once in 100 milliseconds.
         */
        _update: function () {

            if (this.updateLock) return;

            this.updateLock = true;
            this.setState({ loading: true });
            this._getData();

            this.lockTimeout = setTimeout(() => {
                this.updateLock = false;
            }, 100);

        },

        /**
         * React Methods
         * --------------------------------------------------------------------
         */

        propTypes: {
            query: function (props, propName) {
                if (!props[propName].isQuery) {
                    return new Error('The query prop must be a Query object.');
                }
            },
            title: PropTypes.string.isRequired,

            summary: PropTypes.oneOfType([ PropTypes.node, PropTypes.func ]),
        },

        getInitialState: function () {

            // Add the keys specified in the menu additions to the Chart's
            // state.
            let menuChoices = mapValues(menuAdditions, 'defaultValue');

            return {
                error: null,
                headerInfo: null,
                loading: true,
                queryResults: null,
                menuChoices,
            }

        },

        componentWillMount: function () {

            // Filter the props object, saving only the props that are Querys.
            let queries = pickBy(this.props, 'isQuery');

            // Subscribe this Widget to all of the queries it depends on,
            // so that when they need to be updated,
            // the Widget will know to update itself.
            forEach(queries, query => query.subscribe(this));

            // Fetch data from the server.
            this._getData();

        },

        componentWillUnmount: function () {
            clearTimeout(this.lockTimeout);
        },

        render: function () {

            let
                chartMenuAdditions,
                queryCalls,
                widget,
                { title, query, summary } = this.props
            ;

            // Early returns for loading and error states.
            if (this.state.loading) {
                return (<Chart title={title} loading={true} />);
            } else if (this.state.error) {
                return (<Chart error={this.state.error} />);
            }

            // Render this Chart's Query call stack, if it can generate one.
            if (isFunction(query.makeDocs)) {
                queryCalls = query.makeDocs();
            }

            // Generate the summary for this Widget. A `summary` can (in some
            // cases) be a function that depends on the output of one or more
            // Querys passed as `props` to this Widget. In that case, the
            // `summary` function is called with this Widget's `state` object,
            // which contains the evaluated results of said Querys.
            if (isFunction(this.props.summary)) {
                let summaryArgs = util.formatNames(this.state.queryResults);
                summary = this.props.summary(summaryArgs);
            }

            if (!summary) {
                summary = `
                    This widget doesn't seem to have a summary, we're sorry!
                    You should contact the NEAT dev team and
                    tell them to work harder.
                `;
            }

            // Transform any specified Chart menu additions into <ChartItem/>s
            // suitable for embedding in a Chart's header menu. The click
            // event handler for the menu addition simply toggles the specified
            // key in the component's state.
            chartMenuAdditions = map(menuAdditions, (spec, key) => {

                let clickHandler = () => {
                    this.setState({
                        menuChoices: assign({}, this.state.menuChoices, {
                            [key]: !this.state.menuChoices[key],
                        }),
                    });
                }

                return (
                    <ChartItem onClick={clickHandler}>
                        { spec.label }
                    </ChartItem>
                );

            });

            if (isEmpty(this.state.queryResults.query.pandas.values)) {
                widget = (<em>No data to display.</em>);
            } else {
                widget = (
                    <Widget
                        { ...this.props }
                        menuChoices={this.state.menuChoices}
                        queryResults={this.state.queryResults}
                    />
                );
            }

            return (
                <Chart
                    downloadCSV={query.toCsv.bind(query)}
                    downloadNotebook={query.toNotebook.bind(query)}
                    downloadXLSX={query.toXlsx.bind(query)}
                    chartMenuAdditions={chartMenuAdditions}
                    queryCalls={queryCalls}
                    summary={summary}
                    title={title}
                >
                    { widget }
                </Chart>
            );

        },

    });

}
